#include <string>

inline static std::string wasm_rt_content =
"/*\n"
" * Copyright 2018 WebAssembly Community Group participants\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"#ifndef WASM_RT_H_\n"
"#define WASM_RT_H_\n"
"\n"
"#include <stdbool.h>\n"
"#include <stdint.h>\n"
"#include <string.h>\n"
"\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"#ifndef __has_builtin\n"
"#define __has_builtin(x) 0  // Compatibility with non-clang compilers.\n"
"#endif\n"
"\n"
"#if __has_builtin(__builtin_expect)\n"
"#define UNLIKELY(x) __builtin_expect(!!(x), 0)\n"
"#define LIKELY(x) __builtin_expect(!!(x), 1)\n"
"#else\n"
"#define UNLIKELY(x) (x)\n"
"#define LIKELY(x) (x)\n"
"#endif\n"
"\n"
"#if __has_builtin(__builtin_memcpy)\n"
"#define wasm_rt_memcpy __builtin_memcpy\n"
"#else\n"
"#define wasm_rt_memcpy memcpy\n"
"#endif\n"
"\n"
"/** Enable memory checking via a signal handler via the following definition:\n"
" *\n"
" * #define WASM_RT_MEMCHECK_SIGNAL_HANDLER 1\n"
" *\n"
" * This is usually 10%-25% faster, but requires OS-specific support.\n"
" * */\n"
"\n"
"/** Check whether the signal handler is supported at all. */\n"
"#if (defined(__linux__) || defined(__unix__) || defined(__APPLE__)) && \\\n"
"    defined(__WORDSIZE) && __WORDSIZE == 64\n"
"\n"
"/* If the signal handler is supported, then use it by default. */\n"
"#ifndef WASM_RT_MEMCHECK_SIGNAL_HANDLER\n"
"#define WASM_RT_MEMCHECK_SIGNAL_HANDLER 1\n"
"#endif\n"
"\n"
"#if WASM_RT_MEMCHECK_SIGNAL_HANDLER\n"
"#define WASM_RT_MEMCHECK_SIGNAL_HANDLER_POSIX 1\n"
"#endif\n"
"\n"
"#else\n"
"\n"
"/* The signal handler is not supported, error out if the user was trying to\n"
" * enable it. */\n"
"#if WASM_RT_MEMCHECK_SIGNAL_HANDLER\n"
"#error \"Signal handler is not supported for this OS/Architecture!\"\n"
"#endif\n"
"\n"
"#define WASM_RT_MEMCHECK_SIGNAL_HANDLER 0\n"
"#define WASM_RT_MEMCHECK_SIGNAL_HANDLER_POSIX 0\n"
"\n"
"/** When the signal handler is not used, stack depth is limited explicitly.\n"
" * The maximum stack depth before trapping can be configured by defining\n"
" * this symbol before including wasm-rt when building the generated c files,\n"
" * for example:\n"
" *\n"
" * ```\n"
" *   cc -c -DWASM_RT_MAX_CALL_STACK_DEPTH=100 my_module.c -o my_module.o\n"
" * ```\n"
" * */\n"
"#ifndef WASM_RT_MAX_CALL_STACK_DEPTH\n"
"#define WASM_RT_MAX_CALL_STACK_DEPTH 500\n"
"#endif\n"
"\n"
"/** Current call stack depth. */\n"
"extern uint32_t wasm_rt_call_stack_depth;\n"
"\n"
"#endif\n"
"\n"
"#if defined(_MSC_VER)\n"
"#define WASM_RT_NO_RETURN __declspec(noreturn)\n"
"#else\n"
"#define WASM_RT_NO_RETURN __attribute__((noreturn))\n"
"#endif\n"
"\n"
"#if defined(__APPLE__) && WASM_RT_MEMCHECK_SIGNAL_HANDLER_POSIX\n"
"#define WASM_RT_MERGED_OOB_AND_EXHAUSTION_TRAPS 1\n"
"#else\n"
"#define WASM_RT_MERGED_OOB_AND_EXHAUSTION_TRAPS 0\n"
"#endif\n"
"\n"
"/** Reason a trap occurred. Provide this to `wasm_rt_trap`. */\n"
"typedef enum {\n"
"  WASM_RT_TRAP_NONE,         /** No error. */\n"
"  WASM_RT_TRAP_OOB,          /** Out-of-bounds access in linear memory. */\n"
"  WASM_RT_TRAP_INT_OVERFLOW, /** Integer overflow on divide or truncation. */\n"
"  WASM_RT_TRAP_DIV_BY_ZERO,  /** Integer divide by zero. */\n"
"  WASM_RT_TRAP_INVALID_CONVERSION, /** Conversion from NaN to integer. */\n"
"  WASM_RT_TRAP_UNREACHABLE,        /** Unreachable instruction executed. */\n"
"  WASM_RT_TRAP_CALL_INDIRECT,      /** Invalid call_indirect, for any reason. */\n"
"#if WASM_RT_MERGED_OOB_AND_EXHAUSTION_TRAPS\n"
"  WASM_RT_TRAP_EXHAUSTION = WASM_RT_TRAP_OOB,\n"
"#else\n"
"  WASM_RT_TRAP_EXHAUSTION, /** Call stack exhausted. */\n"
"#endif\n"
"} wasm_rt_trap_t;\n"
"\n"
"/** Value types. Used to define function signatures. */\n"
"typedef enum {\n"
"  WASM_RT_I32,\n"
"  WASM_RT_I64,\n"
"  WASM_RT_F32,\n"
"  WASM_RT_F64,\n"
"} wasm_rt_type_t;\n"
"\n"
"/** A function type for all `funcref` functions in a Table. All functions are\n"
" * stored in this canonical form, but must be cast to their proper signature to\n"
" * call. */\n"
"typedef void (*wasm_rt_funcref_t)(void);\n"
"\n"
"/** A single element of a Table. */\n"
"typedef struct {\n"
"  /** The index as returned from `wasm_rt_register_func_type`. */\n"
"  uint32_t func_type;\n"
"  /** The function. The embedder must know the actual C signature of the\n"
"   * function and cast to it before calling. */\n"
"  wasm_rt_funcref_t func;\n"
"  /** The module instance. The pointer to the module instance that should\n"
"   * be passed into the function. */\n"
"  void* module_instance;\n"
"} wasm_rt_elem_t;\n"
"\n"
"/** A Memory object. */\n"
"typedef struct {\n"
"  /** The linear memory data, with a byte length of `size`. */\n"
"  uint8_t* data;\n"
"  /** The current and maximum page count for this Memory object. If there is no\n"
"   * maximum, `max_pages` is 0xffffffffu (i.e. UINT32_MAX). */\n"
"  uint32_t pages, max_pages;\n"
"  /** The current size of the linear memory, in bytes. */\n"
"  uint32_t size;\n"
"} wasm_rt_memory_t;\n"
"\n"
"/** A Table object. */\n"
"typedef struct {\n"
"  /** The table element data, with an element count of `size`. */\n"
"  wasm_rt_elem_t* data;\n"
"  /** The maximum element count of this Table object. If there is no maximum,\n"
"   * `max_size` is 0xffffffffu (i.e. UINT32_MAX). */\n"
"  uint32_t max_size;\n"
"  /** The current element count of the table. */\n"
"  uint32_t size;\n"
"} wasm_rt_table_t;\n"
"\n"
"/** Initialize the runtime. */\n"
"void wasm_rt_init();\n"
"\n"
"/** Free the runtime's state. */\n"
"void wasm_rt_free();\n"
"\n"
"/** Stop execution immediately and jump back to the call to `wasm_rt_try`.\n"
" *  The result of `wasm_rt_try` will be the provided trap reason.\n"
" *\n"
" *  This is typically called by the generated code, and not the embedder. */\n"
"WASM_RT_NO_RETURN void wasm_rt_trap(wasm_rt_trap_t);\n"
"\n"
"/**\n"
" * Return a human readable error string based on a trap type.\n"
" */\n"
"const char* wasm_rt_strerror(wasm_rt_trap_t trap);\n"
"\n"
"/** Register a function type with the given signature. The returned function\n"
" * index is guaranteed to be the same for all calls with the same signature.\n"
" * The following varargs must all be of type `wasm_rt_type_t`, first the\n"
" * params` and then the `results`.\n"
" *\n"
" *  ```\n"
" *    // Register (func (param i32 f32) (result i64)).\n"
" *    wasm_rt_register_func_type(2, 1, WASM_RT_I32, WASM_RT_F32, WASM_RT_I64);\n"
" *    => returns 1\n"
" *\n"
" *    // Register (func (result i64)).\n"
" *    wasm_rt_register_func_type(0, 1, WASM_RT_I32);\n"
" *    => returns 2\n"
" *\n"
" *    // Register (func (param i32 f32) (result i64)) again.\n"
" *    wasm_rt_register_func_type(2, 1, WASM_RT_I32, WASM_RT_F32, WASM_RT_I64);\n"
" *    => returns 1\n"
" *  ``` */\n"
"extern uint32_t wasm_rt_register_func_type(uint32_t params,\n"
"                                           uint32_t results,\n"
"                                           ...);\n"
"\n"
"/** Initialize a Memory object with an initial page size of `initial_pages` and\n"
" * a maximum page size of `max_pages`.\n"
" *\n"
" *  ```\n"
" *    wasm_rt_memory_t my_memory;\n"
" *    // 1 initial page (65536 bytes), and a maximum of 2 pages.\n"
" *    wasm_rt_allocate_memory(&my_memory, 1, 2);\n"
" *  ``` */\n"
"extern void wasm_rt_allocate_memory(wasm_rt_memory_t*,\n"
"                                    uint32_t initial_pages,\n"
"                                    uint32_t max_pages);\n"
"\n"
"/** Grow a Memory object by `pages`, and return the previous page count. If\n"
" * this new page count is greater than the maximum page count, the grow fails\n"
" * and 0xffffffffu (UINT32_MAX) is returned instead.\n"
" *\n"
" *  ```\n"
" *    wasm_rt_memory_t my_memory;\n"
" *    ...\n"
" *    // Grow memory by 10 pages.\n"
" *    uint32_t old_page_size = wasm_rt_grow_memory(&my_memory, 10);\n"
" *    if (old_page_size == UINT32_MAX) {\n"
" *      // Failed to grow memory.\n"
" *    }\n"
" *  ``` */\n"
"extern uint32_t wasm_rt_grow_memory(wasm_rt_memory_t*, uint32_t pages);\n"
"\n"
"/**\n"
" * Free a Memory object.\n"
" */\n"
"extern void wasm_rt_free_memory(wasm_rt_memory_t*);\n"
"\n"
"/** Initialize a Table object with an element count of `elements` and a maximum\n"
" * page size of `max_elements`.\n"
" *\n"
" *  ```\n"
" *    wasm_rt_table_t my_table;\n"
" *    // 5 elemnets and a maximum of 10 elements.\n"
" *    wasm_rt_allocate_table(&my_table, 5, 10);\n"
" *  ``` */\n"
"extern void wasm_rt_allocate_table(wasm_rt_table_t*,\n"
"                                   uint32_t elements,\n"
"                                   uint32_t max_elements);\n"
"\n"
"/**\n"
" * Free a Table object.\n"
" */\n"
"extern void wasm_rt_free_table(wasm_rt_table_t*);\n"
"\n"
"#ifdef _WIN32\n"
"float wasm_rt_truncf(float x);\n"
"double wasm_rt_trunc(double x);\n"
"float wasm_rt_nearbyintf(float x);\n"
"double wasm_rt_nearbyint(double x);\n"
"float wasm_rt_fabsf(float x);\n"
"double wasm_rt_fabs(double x);\n"
"#else\n"
"#define wasm_rt_truncf(x) truncf(x)\n"
"#define wasm_rt_trunc(x) trunc(x)\n"
"#define wasm_rt_nearbyintf(x) nearbyintf(x)\n"
"#define wasm_rt_nearbyint(x) nearbyint(x)\n"
"#define wasm_rt_fabsf(x) fabsf(x)\n"
"#define wasm_rt_fabs(x) fabs(x)\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif /* WASM_RT_H_ */\n"
;

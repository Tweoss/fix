use std::{marker::PhantomData, mem::forget, sync::Mutex};

use lazy_static::lazy_static;
use seq_macro::seq;

#[repr(C)]
pub struct ExternRef<T> {
    id: usize,
    _type: PhantomData<fn(T)>,
}

impl<T> Drop for ExternRef<T> {
    fn drop(&mut self) {
        _fixpoint_return_slab(self.id);
    }
}

impl<T> ExternRef<T> {
    pub fn cast<S>(self) -> ExternRef<S> {
        let out = ExternRef {
            id: self.id,
            _type: PhantomData,
        };
        forget(self);
        out
    }
}

pub struct Thunk;
pub struct ResourceLimits;
pub struct Blob;

#[repr(C)]
pub struct Slab {
    index: usize,
}

impl Slab {
    fn new(index: usize) -> Self {
        Self { index }
    }
}

/// A book-keeping index of which spots
/// in the WASM externref table are in use
struct Index {
    free_slabs: Vec<Slab>,
    /// Double when size is filled up (all slabs are taken)
    size: usize,
}

impl Index {
    fn new() -> Self {
        unsafe { table_grow(10) };
        Self {
            free_slabs: (0..10).map(|i| Slab::new(i)).collect::<Vec<_>>(),
            size: 10,
        }
    }
    /// Obtains and marks as used an index in the externref table
    fn take_slab(&mut self) -> Slab {
        if self.free_slabs.is_empty() {
            unsafe { table_grow(self.size) };
            self.free_slabs
                .extend((self.size..(2 * self.size)).map(|i| Slab::new(i)));
        }
        // self.size is never 0, therefore the length of free_slabs
        // must always be greater or equal to 1
        unsafe { self.free_slabs.pop().unwrap_unchecked() }
    }
    fn return_slab(&mut self, slab: Slab) {
        self.free_slabs.push(slab);
    }
}

lazy_static! {
    static ref INDEX: Mutex<Index> = Mutex::new(Index::new());
}

#[link(wasm_import_module = "fix_api_shim")]
extern "C" {
    /// Wraps a real call to fix_api create_thunk
    /// Generated by post-processing
    /// Post processing will import real create_thunk and call
    /// appropriate table_get and table_set functions as well as
    /// take_slab
    /// manages slabs as well
    pub fn create_thunk(thunk: &ExternRef<Thunk>) -> ExternRef<Thunk>;
    seq! {I in 0..=7 {
        pub fn get_ro_table_~I(index: i32) -> ExternRef<()>;
        pub fn size_ro_table_~I() -> i32;
        pub fn get_attached_tree_ro_table_~I() -> ExternRef<()>;
        pub fn attach_tree_ro_table_~I(name: &ExternRef<()>);
    }}
    seq! {I in 0..=3 {
        pub fn get_i32_ro_mem_~I(index: i32) -> i32;
        pub fn byte_size_ro_mem_~I() -> i32;
        pub fn get_attached_blob_ro_mem_~I() -> ExternRef<()>;
        pub fn attach_blob_ro_mem_~I(value: &ExternRef<()>);
    }}
    seq! {I in 0..=2 {
        // rw_table
        pub fn get_rw_table_~I(index: i32) -> ExternRef<()>;
        pub fn size_rw_table_~I() -> i32;
        pub fn grow_rw_table_~I(index: i32, resource_limits: &ExternRef<()>) -> i32;
        pub fn set_rw_table_~I(index: i32, value: &ExternRef<()>);
        pub fn create_tree_rw_table_~I(size: i32) -> ExternRef<()>;
        // rw_mem
        pub fn get_i32_rw_mem_~I(index: i32) -> i32;
        pub fn set_i32_rw_mem_~I(index: i32, value: i32);
        pub fn grow_rw_mem_~I(size: i32) -> i32;
        pub fn create_blob_rw_mem_~I(size: i32) -> ExternRef<()>;
    }}
    #[link_name = "size_rw_mem_0"]
    pub fn page_size_rw_mem_0() -> i32;
    #[link_name = "size_rw_mem_1"]
    pub fn page_size_rw_mem_1() -> i32;
    #[link_name = "size_rw_mem_2"]
    pub fn page_size_rw_mem_2() -> i32;
    seq! {I in 0..=2 {
        // ro_mem to rw
        pub fn copy_ro_mem_0_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        pub fn copy_ro_mem_1_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        pub fn copy_ro_mem_2_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        pub fn copy_ro_mem_3_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        // ro_table to rw
        pub fn copy_ro_table_0_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        pub fn copy_ro_table_1_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        pub fn copy_ro_table_2_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        pub fn copy_ro_table_3_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        pub fn copy_ro_table_4_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        pub fn copy_ro_table_5_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        pub fn copy_ro_table_6_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
        pub fn copy_ro_table_7_to_rw_~I(rw_offset: i32, ro_offset: i32, length: i32);
    }}

    pub fn create_blob_i32(value: i32) -> ExternRef<i32>;
    /// Grows the table by this amount. Generated by post-processing
    fn table_grow(delta: usize);
}

#[link(wasm_import_module = "fixpoint")]
extern "C" {
    /// Prints to stdout
    pub fn unsafe_io(str: *const u8, length: usize);
}

#[export_name = "_fixpoint_return_slab"]
pub extern "C" fn _fixpoint_return_slab(index: usize) {
    let mut guard = INDEX.lock().unwrap();
    guard.return_slab(Slab::new(index))
}
#[export_name = "_fixpoint_take_slab"]
pub extern "C" fn _fixpoint_take_slab() -> usize {
    let mut guard = INDEX.lock().unwrap();
    guard.take_slab().index
}

// WASM CODE
//   ;; rename table_grow, create_thunk
//   ;; just don't delete fd_write
//   ;; (import "fix_api_shim" "table_grow" (func $helloworld::fix_api::table_grow::h43e11f3fe46da0b1 (type 2)))
//   ;; (import "fix_api_shim" "create_thunk" (func $fix_api_create_thunk (type 3)))
//   ;; (import "wasi_snapshot_preview1" "environ_get" (func $__imported_wasi_snapshot_preview1_environ_get (type 6)))
//   ;; (import "wasi_snapshot_preview1" "environ_sizes_get" (func $__imported_wasi_snapshot_preview1_environ_sizes_get (type 6)))
//   ;; (import "wasi_snapshot_preview1" "proc_exit" (func $__imported_wasi_snapshot_preview1_proc_exit (type 2)))
//   ;; == start addition ==
//   (import "fixpoint" "create_thunk" (func $_fix_api_create_thunk (param externref) (result externref)))
//   (func $fix_api_table_grow_RENAME_ME (param $offset i32)
//     ref.null extern
//     local.get $offset
//     table.grow $_fixpoint_externref_table
//     drop
//   )
//   (func $fix_api_create_thunk_RENAME_ME (param i32) (result i32) (local $index i32)
//     ;; if the api call should consume the externref, use _fixpoint_return_slab
//     ;; get a slab
//     call $_fixpoint_take_slab.command_export
//     local.tee $index
//     ;; dereference the argument (takes a reference to an index)
//     local.get 0
//     i32.load
//     ;; get the actual externref from the table
//     table.get $_fixpoint_externref_table
//     ;; apply create_thunk
//     call $_fix_api_create_thunk
//     ;; store the externref
//     table.set $_fixpoint_externref_table
//     local.get $index
//   )
//   (func $_fixpoint_apply (param externref) (result externref) (local $index i32)
//     call $_fixpoint_take_slab.command_export
//     local.set $index
//     (table.set $_fixpoint_externref_table (local.get $index) (local.get 0))
//     (local.set $index (call $_fixpoint_apply_base.command_export (local.get $index)))
//     (table.get $_fixpoint_externref_table (local.get $index))
//   )
//   ;; loop infinitely instead of exiting
//   (func $__imported_wasi_snapshot_preview1_proc_exit (param i32)
//     (loop)
//   )
//   ;; set number of args to 0 and size of string for env var data to be 0
//   (func $__imported_wasi_snapshot_preview1_environ_sizes_get (param i32) (param i32) (result i32)
//     (i32.store (local.get 0) (i32.const 0))
//     (i32.store (local.get 1) (i32.const 0))
//     i32.const 0
//   )
//   ;; no-op, return 0.
//   (func $__imported_wasi_snapshot_preview1_environ_get (param i32) (param i32) (result i32)
//     i32.const 0
//   )
//   ;; == end addition ==

//   ;; (export "_fixpoint_return_slab" (func $_fixpoint_return_slab.command_export))
//   ;; (export "_fixpoint_take_slab" (func $_fixpoint_take_slab.command_export))
//   ;; == start addition ==
//   (export "_fixpoint_apply" (func $_fixpoint_apply))
//   (table $_fixpoint_externref_table 0 externref)
//   ;; == end addition ==
